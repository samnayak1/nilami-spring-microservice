spring.application.name=API-GATEWAY


server.port=8084


eureka.instance.hostname=localhost


eureka.client.fetch-registry=true
eureka.instance.prefer-ip-address=true
eureka.client.service-url.defaultZone=${EUREKA_HOST}/eureka

spring.cloud.discovery.enabled=true

# User bid route
spring.cloud.gateway.server.webflux.routes[0].id=BID-SERVICE
spring.cloud.gateway.server.webflux.routes[0].uri=${BID_SERVICE_HOST}
spring.cloud.gateway.server.webflux.routes[0].predicates[0]=Path=/api/v1/bids/**




spring.cloud.gateway.server.webflux.routes[0].filters[0].name=CircuitBreaker
spring.cloud.gateway.server.webflux.routes[0].filters[0].args.name=bidServiceCircuitBreaker
spring.cloud.gateway.server.webflux.routes[0].filters[0].args.fallbackUri=forward:/fallback/bids



# Hotel catalog route
spring.cloud.gateway.server.webflux.routes[1].id=CATALOG-SERVICE
spring.cloud.gateway.server.webflux.routes[1].uri=${CATALOG_SERVICE_HOST}
spring.cloud.gateway.server.webflux.routes[1].predicates[0]=Path=/api/v1/categories/**
spring.cloud.gateway.server.webflux.routes[1].predicates[1]=Path=/api/v1/items/**

spring.cloud.gateway.server.webflux.routes[1].filters[0].name=CircuitBreaker
spring.cloud.gateway.server.webflux.routes[1].filters[0].args.name=catalogServiceCircuitBreaker
spring.cloud.gateway.server.webflux.routes[1].filters[0].args.fallbackUri=forward:/fallback/catalog



# Rating auth route
spring.cloud.gateway.server.webflux.routes[2].id=AUTH-SERVICE
spring.cloud.gateway.server.webflux.routes[2].uri=${AUTH_SERVICE_HOST}
spring.cloud.gateway.server.webflux.routes[2].predicates[0]=Path=/api/v1/auth/**

spring.cloud.gateway.server.webflux.routes[2].filters[0].name=CircuitBreaker
spring.cloud.gateway.server.webflux.routes[2].filters[0].args.name=authServiceCircuitBreaker
spring.cloud.gateway.server.webflux.routes[2].filters[0].args.fallbackUri=forward:/fallback/auth


spring.security.oauth2.resourceserver.jwt.issuer-uri=http://keycloak:8080/realms/nilami-microservices-security-realm


keycloak.realm=${KEYCLOAK_REALM}

resilience4j.circuitbreaker.instances.externalApi.register-health-indicator: true
resilience4j.circuitbreaker.instances.externalApi.sliding-window-size: 10
# Resilience4j will keep statistics for the last 10 calls.

# It then calculates how many of those failed (e.g., timeout, exception, 5xx).

# If the failure rate exceeds the configured threshold (say failure-rate-threshold=50), the breaker will open.
   
resilience4j.circuitbreaker.instances.externalApi.permitted-number-of-calls-in-half-open-state: 3
#minimum number of calls that must be recorded before the circuit breaker can calculate failure rates
resilience4j.circuitbreaker.instances.externalApi.minimum-number-of-calls: 5
resilience4j.circuitbreaker.instances.externalApi.wait-duration-in-open-state: 10s
#This defines how long the breaker stays open before moving into half-open (test) mode.
resilience4j.circuitbreaker.instances.externalApi.failure-rate-threshold: 50
